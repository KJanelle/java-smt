


<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8"> 
  <title>Coverage Report > Visitor</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">org.sosy_lab.java_smt.basicimpl.parserInterpreter</a>
</div>

<h1>Coverage Summary for Class: Visitor (org.sosy_lab.java_smt.basicimpl.parserInterpreter)</h1>

<table class="coverageStats">
<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Class, %
</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Branch, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">Visitor</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    97,4%
  </span>
  <span class="absValue">
    (37/38)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    78,4%
  </span>
  <span class="absValue">
    (395/504)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    93,2%
  </span>
  <span class="absValue">
    (674/723)
  </span>
</td>
</tr>

</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;/*
&nbsp; *  JavaSMT is an API wrapper for a collection of SMT solvers.
&nbsp; *  This file is part of JavaSMT.
&nbsp; *
&nbsp; *  Copyright (C) 2007-2016  Dirk Beyer
&nbsp; *  All rights reserved.
&nbsp; *
&nbsp; *  Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
&nbsp; *  you may not use this file except in compliance with the License.
&nbsp; *  You may obtain a copy of the License at
&nbsp; *
&nbsp; *      http://www.apache.org/licenses/LICENSE-2.0
&nbsp; *
&nbsp; *  Unless required by applicable law or agreed to in writing, software
&nbsp; *  distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
&nbsp; *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
&nbsp; *  See the License for the specific language governing permissions and
&nbsp; *  limitations under the License.
&nbsp; */
&nbsp;
&nbsp;package org.sosy_lab.java_smt.basicimpl.parserInterpreter;
&nbsp;
&nbsp;import com.google.common.base.Splitter;
&nbsp;import com.google.common.collect.Iterables;
&nbsp;import java.math.BigInteger;
&nbsp;import java.util.ArrayList;
&nbsp;import java.util.HashMap;
&nbsp;import java.util.Iterator;
&nbsp;import java.util.List;
&nbsp;import java.util.Objects;
&nbsp;import java.util.stream.Collectors;
&nbsp;import org.checkerframework.checker.nullness.qual.Nullable;
&nbsp;import org.sosy_lab.java_smt.api.ArrayFormula;
&nbsp;import org.sosy_lab.java_smt.api.ArrayFormulaManager;
&nbsp;import org.sosy_lab.java_smt.api.BitvectorFormula;
&nbsp;import org.sosy_lab.java_smt.api.BitvectorFormulaManager;
&nbsp;import org.sosy_lab.java_smt.api.BooleanFormula;
&nbsp;import org.sosy_lab.java_smt.api.BooleanFormulaManager;
&nbsp;import org.sosy_lab.java_smt.api.Formula;
&nbsp;import org.sosy_lab.java_smt.api.FormulaManager;
&nbsp;import org.sosy_lab.java_smt.api.FormulaType;
&nbsp;import org.sosy_lab.java_smt.api.FormulaType.BitvectorType;
&nbsp;import org.sosy_lab.java_smt.api.FunctionDeclaration;
&nbsp;import org.sosy_lab.java_smt.api.IntegerFormulaManager;
&nbsp;import org.sosy_lab.java_smt.api.Model;
&nbsp;import org.sosy_lab.java_smt.api.Model.ValueAssignment;
&nbsp;import org.sosy_lab.java_smt.api.NumeralFormula;
&nbsp;import org.sosy_lab.java_smt.api.NumeralFormula.IntegerFormula;
&nbsp;import org.sosy_lab.java_smt.api.NumeralFormula.RationalFormula;
&nbsp;import org.sosy_lab.java_smt.api.RationalFormulaManager;
&nbsp;import org.sosy_lab.java_smt.api.UFManager;
&nbsp;import org.sosy_lab.java_smt.basicimpl.ParserException;
&nbsp;import org.sosy_lab.java_smt.basicimpl.parserInterpreter.smtlibv2Parser.Cmd_assertContext;
&nbsp;import org.sosy_lab.java_smt.basicimpl.parserInterpreter.smtlibv2Parser.Cmd_declareConstContext;
&nbsp;import org.sosy_lab.java_smt.basicimpl.parserInterpreter.smtlibv2Parser.Cmd_declareFunContext;
&nbsp;import org.sosy_lab.java_smt.basicimpl.parserInterpreter.smtlibv2Parser.Cmd_popContext;
&nbsp;import org.sosy_lab.java_smt.basicimpl.parserInterpreter.smtlibv2Parser.Cmd_pushContext;
&nbsp;import org.sosy_lab.java_smt.basicimpl.parserInterpreter.smtlibv2Parser.Decl_sortContext;
&nbsp;import org.sosy_lab.java_smt.basicimpl.parserInterpreter.smtlibv2Parser.Function_defContext;
&nbsp;import org.sosy_lab.java_smt.basicimpl.parserInterpreter.smtlibv2Parser.Id_symbContext;
&nbsp;import org.sosy_lab.java_smt.basicimpl.parserInterpreter.smtlibv2Parser.Id_symb_idxContext;
&nbsp;import org.sosy_lab.java_smt.basicimpl.parserInterpreter.smtlibv2Parser.MultisortContext;
&nbsp;import org.sosy_lab.java_smt.basicimpl.parserInterpreter.smtlibv2Parser.MultitermContext;
&nbsp;import org.sosy_lab.java_smt.basicimpl.parserInterpreter.smtlibv2Parser.Qual_id_sortContext;
&nbsp;import org.sosy_lab.java_smt.basicimpl.parserInterpreter.smtlibv2Parser.Resp_get_modelContext;
&nbsp;import org.sosy_lab.java_smt.basicimpl.parserInterpreter.smtlibv2Parser.Sort_idContext;
&nbsp;import org.sosy_lab.java_smt.basicimpl.parserInterpreter.smtlibv2Parser.Spec_constant_binContext;
&nbsp;import org.sosy_lab.java_smt.basicimpl.parserInterpreter.smtlibv2Parser.Term_exclamContext;
&nbsp;import org.sosy_lab.java_smt.basicimpl.parserInterpreter.smtlibv2Parser.Term_existsContext;
&nbsp;import org.sosy_lab.java_smt.basicimpl.parserInterpreter.smtlibv2Parser.Term_forallContext;
&nbsp;import org.sosy_lab.java_smt.basicimpl.parserInterpreter.smtlibv2Parser.Term_letContext;
&nbsp;import org.sosy_lab.java_smt.basicimpl.parserInterpreter.smtlibv2Parser.Term_qual_idContext;
&nbsp;import org.sosy_lab.java_smt.basicimpl.parserInterpreter.smtlibv2Parser.Term_spec_constContext;
&nbsp;import org.sosy_lab.java_smt.basicimpl.parserInterpreter.smtlibv2Parser.Var_bindingContext;
&nbsp;import scala.Tuple2;
&nbsp;
&nbsp;
&nbsp;/**
&nbsp; * Implements a method from smtlibv2BaseVisitor for each node in a parse tree that requires some
&nbsp; * form of action in order to transform the parsed SMT-LIB2 into JavaSMT
&nbsp; */
&nbsp;@SuppressWarnings({&quot;CheckReturnValue&quot;, &quot;unchecked&quot;})
&nbsp;public class Visitor extends smtlibv2BaseVisitor&lt;Object&gt; {
&nbsp;
&nbsp;  /**
&nbsp;   * saves all created Formulas that are not part of a let statement as ParserFormula objects with
&nbsp;   * their variable name or value as key
&nbsp;   */
<b class="fc">&nbsp;  public static final HashMap&lt;String, ParserFormula&gt; variables = new HashMap&lt;&gt;();</b>
&nbsp;  /**
&nbsp;   * saves all created Formulas that are part of a let statement as ParserFormula objects with
&nbsp;   * their variable name or value as key
&nbsp;   */
<b class="fc">&nbsp;  public static final HashMap&lt;String, ParserFormula&gt; letVariables = new HashMap&lt;&gt;();</b>
&nbsp;  /**
&nbsp;   * saves each &#39;assert&#39; statement interpreted as a BooleanFormula object as an entry
&nbsp;   */
<b class="fc">&nbsp;  public static final List&lt;BooleanFormula&gt; constraints = new ArrayList&lt;&gt;();</b>
&nbsp;  private final FormulaManager fmgr;
&nbsp;  private final BooleanFormulaManager bmgr;
&nbsp;  private final @Nullable IntegerFormulaManager imgr;
&nbsp;  private final @Nullable RationalFormulaManager rmgr;
&nbsp;  private final @Nullable BitvectorFormulaManager bimgr;
&nbsp;  private final @Nullable ArrayFormulaManager amgr;
&nbsp;  private final UFManager umgr;
<b class="fc">&nbsp;  List&lt;Model.ValueAssignment&gt; assignments = new ArrayList&lt;&gt;();</b>
&nbsp;
&nbsp;  public List&lt;BooleanFormula&gt; getConstraints() {
<b class="fc">&nbsp;    return constraints;</b>
&nbsp;  }
&nbsp;
&nbsp;  public List&lt;ValueAssignment&gt; getAssignments() {
<b class="fc">&nbsp;    return assignments;</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * is set to &#39;true&#39; if a node &#39;model&#39; is encountered
&nbsp;   */
<b class="fc">&nbsp;  private boolean isModel = false;</b>
&nbsp;
&nbsp;  public Visitor(
&nbsp;      FormulaManager fmgr,
&nbsp;      BooleanFormulaManager bmgr,
&nbsp;      @Nullable IntegerFormulaManager imgr,
&nbsp;      @Nullable RationalFormulaManager rmgr,
&nbsp;      @Nullable BitvectorFormulaManager bimgr,
&nbsp;      @Nullable ArrayFormulaManager amgr,
<b class="fc">&nbsp;      UFManager umgr) {</b>
<b class="fc">&nbsp;    this.fmgr = fmgr;</b>
<b class="fc">&nbsp;    this.bmgr = bmgr;</b>
<b class="fc">&nbsp;    this.imgr = imgr;</b>
<b class="fc">&nbsp;    this.rmgr = rmgr;</b>
<b class="fc">&nbsp;    this.bimgr = bimgr;</b>
<b class="fc">&nbsp;    this.amgr = amgr;</b>
<b class="fc">&nbsp;    this.umgr = umgr;</b>
&nbsp;  }
&nbsp;
&nbsp;  public boolean isModel() {
<b class="nc">&nbsp;    return isModel;</b>
&nbsp;  }
&nbsp;
&nbsp;  @Override
&nbsp;  public List&lt;String&gt; visitId_symb(Id_symbContext ctx) {
<b class="fc">&nbsp;    List&lt;String&gt; sort = new ArrayList&lt;&gt;();</b>
<b class="fc">&nbsp;    sort.add(ctx.getText());</b>
<b class="fc">&nbsp;    return sort;</b>
&nbsp;  }
&nbsp;
&nbsp;  @Override
&nbsp;  public List&lt;String&gt; visitId_symb_idx(Id_symb_idxContext ctx) {
<b class="fc">&nbsp;    List&lt;String&gt; sort = new ArrayList&lt;&gt;();</b>
<b class="fc">&nbsp;    sort.add(ctx.symbol().getText());</b>
<b class="fc">&nbsp;    for (int i = 0; i &lt; ctx.index().size(); i++) {</b>
<b class="fc">&nbsp;      sort.add(ctx.index(i).getText());</b>
&nbsp;    }
<b class="fc">&nbsp;    return sort;</b>
&nbsp;  }
&nbsp;
&nbsp;  @Override
&nbsp;  public FormulaType.ArrayFormulaType&lt;?, ?&gt; visitMultisort(MultisortContext ctx) {
&nbsp;    FormulaType.ArrayFormulaType&lt;?, ?&gt; result;
<b class="pc">&nbsp;    if (ctx.identifier().getText().equals(&quot;Array&quot;)) {</b>
<b class="fc">&nbsp;      FormulaType&lt;?&gt; idx = (FormulaType&lt;?&gt;) visit(ctx.sort(0));</b>
<b class="fc">&nbsp;      FormulaType&lt;?&gt; elem = (FormulaType&lt;?&gt;) visit(ctx.sort(1));</b>
<b class="fc">&nbsp;      result = FormulaType.getArrayType(idx, elem);</b>
<b class="fc">&nbsp;    } else {</b>
<b class="nc">&nbsp;      throw new ParserException(ctx.identifier().getText() + &quot; is not a known sort. &quot;);</b>
&nbsp;    }
&nbsp;
<b class="fc">&nbsp;    return result;</b>
&nbsp;  }
&nbsp;
&nbsp;  @Override
&nbsp;  public FormulaType&lt;?&gt; visitSort_id(Sort_idContext ctx) {
<b class="fc">&nbsp;    String type = ctx.getText();</b>
&nbsp;
<b class="fc">&nbsp;    String bvSize = &quot;&quot;;</b>
<b class="fc">&nbsp;    if (type.startsWith(&quot;(_BitVec&quot;)) {</b>
<b class="fc">&nbsp;      bvSize = Iterables.get(Splitter.on(&quot;_BitVec&quot;).split(type), 1);</b>
<b class="fc">&nbsp;      bvSize = Iterables.get(Splitter.on(&#39;)&#39;).split(bvSize), 0);</b>
<b class="fc">&nbsp;      type = &quot;BitVec&quot;;</b>
&nbsp;    }
&nbsp;
<b class="pc">&nbsp;    switch (type) {</b>
&nbsp;      case &quot;Int&quot;:
<b class="fc">&nbsp;        return FormulaType.IntegerType;</b>
&nbsp;      case &quot;Bool&quot;:
<b class="fc">&nbsp;        return FormulaType.BooleanType;</b>
&nbsp;      case &quot;Real&quot;:
<b class="fc">&nbsp;        return FormulaType.RationalType;</b>
&nbsp;      case &quot;BitVec&quot;:
<b class="fc">&nbsp;        return FormulaType.getBitvectorTypeWithSize(Integer.parseInt(bvSize));</b>
&nbsp;      default:
<b class="nc">&nbsp;        throw new ParserException(type + &quot; is not a known Array sort. &quot;);</b>
&nbsp;    }
&nbsp;  }
&nbsp;
&nbsp;  @Override
&nbsp;  public Tuple2&lt;String, FormulaType&lt;?&gt;&gt; visitQual_id_sort(Qual_id_sortContext ctx) {
<b class="fc">&nbsp;    String operator = ctx.identifier().getText();</b>
<b class="fc">&nbsp;    FormulaType&lt;?&gt; sort = (FormulaType&lt;?&gt;) visit(ctx.sort());</b>
<b class="fc">&nbsp;    Tuple2&lt;String, FormulaType&lt;?&gt;&gt; result = new Tuple2&lt;&gt;(operator, sort);</b>
<b class="fc">&nbsp;    return result;</b>
&nbsp;  }
&nbsp;
&nbsp;  @Override
&nbsp;  public Object visitVar_binding(Var_bindingContext ctx) {
<b class="fc">&nbsp;    String name = ctx.symbol().getText();</b>
<b class="fc">&nbsp;    Formula formula = (Formula) visit(ctx.term());</b>
<b class="fc">&nbsp;    letVariables.put(name, new ParserFormula(formula));</b>
<b class="fc">&nbsp;    return visitChildren(ctx);</b>
&nbsp;  }
&nbsp;
&nbsp;  public static boolean isInteger(String strNum) {
&nbsp;    try {
<b class="fc">&nbsp;      Integer.parseInt(strNum);</b>
<b class="fc">&nbsp;    } catch (NumberFormatException nfe) {</b>
<b class="fc">&nbsp;      return false;</b>
<b class="fc">&nbsp;    }</b>
<b class="fc">&nbsp;    return true;</b>
&nbsp;  }
&nbsp;
&nbsp;  public static boolean isFloat(String strNum) {
&nbsp;    try {
<b class="fc">&nbsp;      Float.parseFloat(strNum);</b>
<b class="fc">&nbsp;    } catch (NumberFormatException nfe) {</b>
<b class="fc">&nbsp;      return false;</b>
<b class="nc">&nbsp;    }</b>
<b class="nc">&nbsp;    return true;</b>
&nbsp;  }
&nbsp;
&nbsp;  public static boolean isDouble(String strNum) {
&nbsp;    try {
<b class="fc">&nbsp;      Double.parseDouble(strNum);</b>
<b class="fc">&nbsp;    } catch (NumberFormatException nfe) {</b>
<b class="fc">&nbsp;      return false;</b>
<b class="fc">&nbsp;    }</b>
<b class="fc">&nbsp;    return true;</b>
&nbsp;  }
&nbsp;
&nbsp;  public static boolean isLong(String strNum) {
&nbsp;    try {
<b class="fc">&nbsp;      Long.parseLong(strNum);</b>
<b class="fc">&nbsp;    } catch (NumberFormatException nfe) {</b>
<b class="fc">&nbsp;      return false;</b>
<b class="nc">&nbsp;    }</b>
<b class="nc">&nbsp;    return true;</b>
&nbsp;  }
&nbsp;
&nbsp;  public static boolean isBigInteger(String strNum) {
<b class="fc">&nbsp;    boolean ret = true;</b>
&nbsp;    try {
<b class="fc">&nbsp;      BigInteger x = new BigInteger(strNum);</b>
<b class="nc">&nbsp;      if (!x.equals(new BigInteger(strNum))) {</b>
<b class="nc">&nbsp;        ret = false;</b>
&nbsp;      }
<b class="fc">&nbsp;    } catch (NumberFormatException nfe) {</b>
<b class="fc">&nbsp;      return false;</b>
<b class="nc">&nbsp;    }</b>
<b class="nc">&nbsp;    return ret;</b>
&nbsp;  }
&nbsp;
&nbsp;  public static String getNumericType(String strNum) {
<b class="fc">&nbsp;    if (isInteger(strNum)) {</b>
<b class="fc">&nbsp;      return &quot;Integer&quot;;</b>
<b class="pc">&nbsp;    } else if (isLong(strNum)) {</b>
<b class="nc">&nbsp;      return &quot;Long&quot;;</b>
<b class="fc">&nbsp;    } else if (isDouble(strNum)) {</b>
<b class="fc">&nbsp;      return &quot;Double&quot;;</b>
<b class="pc">&nbsp;    } else if (isBigInteger(strNum)) {</b>
<b class="nc">&nbsp;      return &quot;BigInteger&quot;;</b>
<b class="pc">&nbsp;    } else if (isFloat(strNum)) {</b>
<b class="nc">&nbsp;      return &quot;Float&quot;;</b>
&nbsp;    } else {
<b class="fc">&nbsp;      return &quot;other&quot;;</b>
&nbsp;    }
&nbsp;  }
&nbsp;
&nbsp;  @Override
&nbsp;  public Object visitTerm_spec_const(Term_spec_constContext ctx) {
<b class="fc">&nbsp;    String operand = ctx.getText();</b>
<b class="fc">&nbsp;    if (variables.containsKey(operand)) {</b>
<b class="fc">&nbsp;      return variables.get(operand).javaSmt;</b>
<b class="fc">&nbsp;    } else if (getNumericType(operand).equals(&quot;Integer&quot;)</b>
<b class="pc">&nbsp;        || getNumericType(operand).equals(&quot;Long&quot;)) {</b>
<b class="fc">&nbsp;      variables.put(</b>
<b class="fc">&nbsp;          operand, new ParserFormula(Objects.requireNonNull(imgr).makeNumber(operand)));</b>
<b class="fc">&nbsp;      return variables.get(operand).javaSmt;</b>
<b class="fc">&nbsp;    } else if (getNumericType(operand).equals(&quot;Double&quot;)</b>
<b class="pc">&nbsp;        || getNumericType(operand).equals(&quot;Float&quot;)) {</b>
<b class="fc">&nbsp;      variables.put(</b>
<b class="fc">&nbsp;          operand, new ParserFormula(Objects.requireNonNull(rmgr).makeNumber(operand)));</b>
<b class="fc">&nbsp;      return variables.get(operand).javaSmt;</b>
<b class="fc">&nbsp;    } else if (operand.startsWith(&quot;#b&quot;)) {</b>
<b class="fc">&nbsp;      String binVal = Iterables.get(Splitter.on(&#39;b&#39;).split(operand), 1);</b>
<b class="fc">&nbsp;      int index = binVal.length();</b>
<b class="fc">&nbsp;      int value = Integer.parseInt(binVal, 2);</b>
<b class="fc">&nbsp;      return Objects.requireNonNull(bimgr).makeBitvector(index, value);</b>
<b class="pc">&nbsp;    } else if (operand.startsWith(&quot;#x&quot;)) {</b>
<b class="fc">&nbsp;      String hexVal = Iterables.get(Splitter.on(&#39;x&#39;).split(operand), 1);</b>
<b class="fc">&nbsp;      int index = (hexVal.length() * 4);</b>
<b class="fc">&nbsp;      BigInteger value = new BigInteger(hexVal, 16);</b>
<b class="fc">&nbsp;      return Objects.requireNonNull(bimgr).makeBitvector(index, value);</b>
&nbsp;    } else {
<b class="nc">&nbsp;      throw new ParserException(&quot;Operand &quot; + operand + &quot; is unknown.&quot;);</b>
&nbsp;    }
&nbsp;  }
&nbsp;
&nbsp;  @Override
&nbsp;  public Object visitTerm_qual_id(Term_qual_idContext ctx) {
<b class="fc">&nbsp;    String operand = replaceReservedChars(ctx.getText());</b>
<b class="fc">&nbsp;    List&lt;String&gt; bitVec = (List&lt;String&gt;) visitChildren(ctx);</b>
<b class="fc">&nbsp;    if (letVariables.containsKey(operand)) {</b>
<b class="pc">&nbsp;      if (!(letVariables.get(operand).type == null) &amp;&amp; Objects.equals(</b>
<b class="nc">&nbsp;          letVariables.get(operand).type, &quot;UF&quot;)</b>
<b class="nc">&nbsp;          &amp;&amp; letVariables.get(operand).inputParams == null) {</b>
<b class="nc">&nbsp;        return umgr.callUF(</b>
<b class="nc">&nbsp;            (FunctionDeclaration&lt;Formula&gt;) letVariables.get(operand).javaSmt, new ArrayList&lt;&gt;());</b>
&nbsp;      }
<b class="fc">&nbsp;      return letVariables.get(operand).javaSmt;</b>
<b class="fc">&nbsp;    } else if (variables.containsKey(operand)) {</b>
<b class="pc">&nbsp;      if (!(variables.get(operand).type == null) &amp;&amp; Objects.equals(variables.get(operand).type,</b>
&nbsp;          &quot;UF&quot;)
<b class="pc">&nbsp;          &amp;&amp; !(variables.get(operand).inputParams == null) &amp;&amp; Objects.requireNonNull(</b>
<b class="pc">&nbsp;          variables.get(operand).inputParams).isEmpty()) {</b>
<b class="fc">&nbsp;        return umgr.callUF(</b>
<b class="fc">&nbsp;            (FunctionDeclaration&lt;Formula&gt;) variables.get(operand).javaSmt, new ArrayList&lt;&gt;());</b>
&nbsp;      }
<b class="fc">&nbsp;      return variables.get(operand).javaSmt;</b>
<b class="fc">&nbsp;    } else if (operand.equals(&quot;false&quot;)) {</b>
<b class="fc">&nbsp;      variables.put(operand, new ParserFormula(bmgr.makeFalse()));</b>
<b class="fc">&nbsp;      return variables.get(operand).javaSmt;</b>
<b class="fc">&nbsp;    } else if (operand.equals(&quot;true&quot;)) {</b>
<b class="fc">&nbsp;      variables.put(operand, new ParserFormula(bmgr.makeTrue()));</b>
<b class="fc">&nbsp;      return variables.get(operand).javaSmt;</b>
<b class="pc">&nbsp;    } else if (!bitVec.isEmpty()) {</b>
<b class="fc">&nbsp;      BigInteger value = new BigInteger(Iterables.get(Splitter.on(&#39;v&#39;).split(bitVec.get(0)), 1));</b>
<b class="fc">&nbsp;      int index = Integer.parseInt(bitVec.get(1));</b>
<b class="fc">&nbsp;      return Objects.requireNonNull(bimgr).makeBitvector(index, value);</b>
&nbsp;    } else {
<b class="nc">&nbsp;      throw new ParserException(&quot;Operand &quot; + operand + &quot; is unknown.&quot;);</b>
&nbsp;    }
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * gets the operands used in a nested term
&nbsp;   * @param ctx current MultitermContext
&nbsp;   * @param operands List of the operands transformed to Formula objects
&nbsp;   */
&nbsp;  public void getOperands(MultitermContext ctx, List&lt;Formula&gt; operands) {
&nbsp;
<b class="fc">&nbsp;    for (int i = 0; i &lt; ctx.term().size(); ++i) {</b>
<b class="fc">&nbsp;      Object operand = visit(ctx.term(i));</b>
<b class="pc">&nbsp;      if (operand != null) {</b>
<b class="fc">&nbsp;        operands.add((Formula) operand);</b>
&nbsp;      }
&nbsp;    }
&nbsp;  }
&nbsp;
&nbsp;  @Override
&nbsp;  public Object visitMultiterm(MultitermContext ctx) {
<b class="fc">&nbsp;    Object identifier = visit(ctx.qual_identifer());</b>
<b class="fc">&nbsp;    List&lt;String&gt; operators = null;</b>
<b class="fc">&nbsp;    String operator = &quot;&quot;;</b>
<b class="fc">&nbsp;    FormulaType&lt;?&gt; sort = null;</b>
<b class="fc">&nbsp;    if (identifier instanceof List) {</b>
<b class="fc">&nbsp;      operators = (List&lt;String&gt;) identifier;</b>
<b class="fc">&nbsp;      operator = Objects.requireNonNull(operators).get(0);</b>
<b class="pc">&nbsp;    } else if (identifier instanceof Tuple2) {</b>
<b class="fc">&nbsp;      operator = ((Tuple2&lt;String, FormulaType&lt;?&gt;&gt;) identifier)._1;</b>
<b class="fc">&nbsp;      sort = ((Tuple2&lt;String, FormulaType&lt;?&gt;&gt;) identifier)._2;</b>
&nbsp;    }
<b class="fc">&nbsp;    operator = replaceReservedChars(operator);</b>
&nbsp;
<b class="fc">&nbsp;    Object ufOperator = null;</b>
<b class="fc">&nbsp;    if (variables.containsKey(operator)) {</b>
<b class="fc">&nbsp;      ufOperator = variables.get(operator).javaSmt;</b>
<b class="fc">&nbsp;      operator = &quot;UF&quot;;</b>
&nbsp;    }
&nbsp;
<b class="fc">&nbsp;    List&lt;Formula&gt; operands = new ArrayList&lt;&gt;();</b>
<b class="fc">&nbsp;    getOperands(ctx, operands);</b>
<b class="pc">&nbsp;    switch (operator) {</b>
&nbsp;        // boolean operators
&nbsp;      case &quot;and&quot;:
&nbsp;        try {
<b class="fc">&nbsp;          List&lt;BooleanFormula&gt; booleanOperands =</b>
<b class="fc">&nbsp;              operands.stream().map(e -&gt; (BooleanFormula) e).collect(Collectors.toList());</b>
<b class="fc">&nbsp;          return bmgr.and(booleanOperands);</b>
<b class="fc">&nbsp;        } catch (Exception e) {</b>
<b class="fc">&nbsp;          throw new ParserException(&quot;Operands for &quot; + operator + &quot; need to be of Boolean type&quot;);</b>
&nbsp;        }
&nbsp;      case &quot;or&quot;:
&nbsp;        try {
<b class="fc">&nbsp;          List&lt;BooleanFormula&gt; booleanOperands =</b>
<b class="fc">&nbsp;              operands.stream().map(e -&gt; (BooleanFormula) e).collect(Collectors.toList());</b>
<b class="fc">&nbsp;          return bmgr.or(booleanOperands);</b>
<b class="fc">&nbsp;        } catch (Exception e) {</b>
<b class="fc">&nbsp;          throw new ParserException(&quot;Operands for &quot; + operator + &quot; need to be of Boolean type&quot;);</b>
&nbsp;        }
&nbsp;      case &quot;xor&quot;:
<b class="fc">&nbsp;        if (operands.size() != 2) {</b>
<b class="fc">&nbsp;          throw new ParserException(operator + &quot; takes two boolean operands as input.&quot;);</b>
&nbsp;        } else {
&nbsp;          try {
<b class="fc">&nbsp;            Iterator&lt;Formula&gt; it = operands.iterator();</b>
<b class="fc">&nbsp;            return bmgr.xor((BooleanFormula) it.next(), (BooleanFormula) it.next());</b>
<b class="fc">&nbsp;          } catch (Exception e) {</b>
<b class="fc">&nbsp;            throw new ParserException(&quot;Operands for &quot; + operator + &quot;need to be of Boolean type&quot;);</b>
&nbsp;          }
&nbsp;        }
&nbsp;      case &quot;not&quot;:
<b class="fc">&nbsp;        if (operands.size() != 1) {</b>
<b class="fc">&nbsp;          throw new ParserException(operator + &quot; takes one boolean operand as input.&quot;);</b>
&nbsp;        } else {
&nbsp;          try {
<b class="fc">&nbsp;            Iterator&lt;Formula&gt; it = operands.iterator();</b>
<b class="fc">&nbsp;            return bmgr.not((BooleanFormula) it.next());</b>
<b class="fc">&nbsp;          } catch (Exception e) {</b>
<b class="fc">&nbsp;            throw new ParserException(&quot;Operands for &quot; + operator + &quot;need to be of Boolean type&quot;);</b>
&nbsp;          }
&nbsp;        }
&nbsp;      case &quot;=&gt;&quot;:
<b class="fc">&nbsp;        if (operands.size() != 2) {</b>
<b class="fc">&nbsp;          throw new ParserException(operator + &quot; takes two boolean operands as input.&quot;);</b>
&nbsp;        } else {
&nbsp;          try {
<b class="fc">&nbsp;            Iterator&lt;Formula&gt; it = operands.iterator();</b>
<b class="fc">&nbsp;            return bmgr.implication((BooleanFormula) it.next(), (BooleanFormula) it.next());</b>
<b class="fc">&nbsp;          } catch (Exception e) {</b>
<b class="fc">&nbsp;            throw new ParserException(&quot;Operands for &quot; + operator + &quot;need to be of Boolean type&quot;);</b>
&nbsp;          }
&nbsp;        }
&nbsp;      case &quot;ite&quot;:
<b class="fc">&nbsp;        if (operands.size() != 3) {</b>
<b class="fc">&nbsp;          throw new ParserException(operator + &quot; takes three boolean operands as input.&quot;);</b>
&nbsp;        } else {
&nbsp;          try {
<b class="fc">&nbsp;            Iterator&lt;Formula&gt; it = operands.iterator();</b>
<b class="fc">&nbsp;            return bmgr.ifThenElse(</b>
<b class="fc">&nbsp;                (BooleanFormula) it.next(), (BooleanFormula) it.next(), (BooleanFormula) it.next());</b>
<b class="fc">&nbsp;          } catch (Exception e) {</b>
<b class="fc">&nbsp;            throw new ParserException(&quot;Operands for &quot; + operator + &quot;need to be of Boolean type&quot;);</b>
&nbsp;          }
&nbsp;        }
&nbsp;        // numeral operators
&nbsp;      case &quot;+&quot;:
<b class="pc">&nbsp;        if (!operands.isEmpty()) {</b>
&nbsp;          try {
<b class="fc">&nbsp;            if (operands.stream().anyMatch(c -&gt; c instanceof RationalFormula)) {</b>
<b class="fc">&nbsp;              List&lt;NumeralFormula&gt; numeralOperands =</b>
<b class="fc">&nbsp;                  operands.stream().map(e -&gt; (NumeralFormula) e).collect(Collectors.toList());</b>
<b class="fc">&nbsp;              return Objects.requireNonNull(rmgr).sum(numeralOperands);</b>
&nbsp;            } else {
<b class="fc">&nbsp;              List&lt;IntegerFormula&gt; integerOperands =</b>
<b class="fc">&nbsp;                  operands.stream().map(e -&gt; (IntegerFormula) e).collect(Collectors.toList());</b>
<b class="fc">&nbsp;              return Objects.requireNonNull(imgr).sum(integerOperands);</b>
&nbsp;            }
<b class="fc">&nbsp;          } catch (Exception e) {</b>
<b class="fc">&nbsp;            throw new ParserException(&quot;Operands for &quot; + operator + &quot;need to be of numeral type&quot;);</b>
&nbsp;          }
&nbsp;        } else {
<b class="nc">&nbsp;          throw new ParserException(operator + &quot; takes at least one numeral operand as input. &quot;);</b>
&nbsp;        }
&nbsp;      case &quot;-&quot;:
<b class="fc">&nbsp;        if (operands.size() == 2) {</b>
&nbsp;          try {
<b class="fc">&nbsp;            if (operands.stream().anyMatch(c -&gt; c instanceof RationalFormula)) {</b>
<b class="fc">&nbsp;              List&lt;NumeralFormula&gt; numeralOperands =</b>
<b class="fc">&nbsp;                  operands.stream().map(e -&gt; (NumeralFormula) e).collect(Collectors.toList());</b>
<b class="fc">&nbsp;              return Objects.requireNonNull(rmgr)</b>
<b class="fc">&nbsp;                  .subtract(numeralOperands.get(0), numeralOperands.get(1));</b>
&nbsp;            } else {
<b class="fc">&nbsp;              List&lt;IntegerFormula&gt; integerOperands =</b>
<b class="fc">&nbsp;                  operands.stream().map(e -&gt; (IntegerFormula) e).collect(Collectors.toList());</b>
<b class="fc">&nbsp;              return Objects.requireNonNull(imgr)</b>
<b class="fc">&nbsp;                  .subtract(integerOperands.get(0), integerOperands.get(1));</b>
&nbsp;            }
<b class="fc">&nbsp;          } catch (Exception e) {</b>
<b class="fc">&nbsp;            throw new ParserException(&quot;Operands for &quot; + operator + &quot;need to be of numeral type&quot;);</b>
&nbsp;          }
<b class="fc">&nbsp;        } else if (operands.size() == 1) {</b>
&nbsp;          try {
<b class="fc">&nbsp;            if (operands.stream().anyMatch(c -&gt; c instanceof RationalFormula)) {</b>
<b class="fc">&nbsp;              List&lt;NumeralFormula&gt; numeralOperands =</b>
<b class="fc">&nbsp;                  operands.stream().map(e -&gt; (NumeralFormula) e).collect(Collectors.toList());</b>
<b class="fc">&nbsp;              return Objects.requireNonNull(rmgr).negate(numeralOperands.get(0));</b>
&nbsp;            } else {
<b class="fc">&nbsp;              List&lt;IntegerFormula&gt; integerOperands =</b>
<b class="fc">&nbsp;                  operands.stream().map(e -&gt; (IntegerFormula) e).collect(Collectors.toList());</b>
<b class="fc">&nbsp;              return Objects.requireNonNull(imgr).negate(integerOperands.get(0));</b>
&nbsp;            }
<b class="nc">&nbsp;          } catch (Exception e) {</b>
<b class="nc">&nbsp;            throw new ParserException(&quot;Operands for &quot; + operator + &quot;need to be of numeral type&quot;);</b>
&nbsp;          }
&nbsp;        } else {
<b class="fc">&nbsp;          throw new ParserException(</b>
&nbsp;              operator + &quot; takes either one or two numeral operands as input. &quot;);
&nbsp;        }
&nbsp;      case &quot;div&quot;:
<b class="fc">&nbsp;        if (operands.size() == 2) {</b>
&nbsp;          try {
<b class="fc">&nbsp;            if (operands.stream().anyMatch(c -&gt; c instanceof RationalFormula)) {</b>
<b class="fc">&nbsp;              List&lt;NumeralFormula&gt; numeralOperands =</b>
<b class="fc">&nbsp;                  operands.stream().map(e -&gt; (NumeralFormula) e).collect(Collectors.toList());</b>
<b class="fc">&nbsp;              return Objects.requireNonNull(rmgr)</b>
<b class="fc">&nbsp;                  .divide(numeralOperands.get(0), numeralOperands.get(1));</b>
&nbsp;            } else {
<b class="fc">&nbsp;              List&lt;IntegerFormula&gt; integerOperands =</b>
<b class="fc">&nbsp;                  operands.stream().map(e -&gt; (IntegerFormula) e).collect(Collectors.toList());</b>
<b class="fc">&nbsp;              return Objects.requireNonNull(imgr)</b>
<b class="fc">&nbsp;                  .divide(integerOperands.get(0), integerOperands.get(1));</b>
&nbsp;            }
<b class="fc">&nbsp;          } catch (Exception e) {</b>
<b class="fc">&nbsp;            throw new ParserException(&quot;Operands for &quot; + operator + &quot;need to be of numeral type&quot;);</b>
&nbsp;          }
&nbsp;        } else {
<b class="fc">&nbsp;          throw new ParserException(operator + &quot; takes two numeral operands as input. &quot;);</b>
&nbsp;        }
&nbsp;      case &quot;mod&quot;:
<b class="fc">&nbsp;        if (operands.size() == 2) {</b>
&nbsp;          try {
<b class="pc">&nbsp;            if (operands.stream().anyMatch(c -&gt; c instanceof RationalFormula)) {</b>
<b class="nc">&nbsp;              throw new ParserException(operator + &quot; is not available for Reals. &quot;);</b>
&nbsp;            } else {
<b class="fc">&nbsp;              List&lt;IntegerFormula&gt; integerOperands =</b>
<b class="fc">&nbsp;                  operands.stream().map(e -&gt; (IntegerFormula) e).collect(Collectors.toList());</b>
<b class="fc">&nbsp;              return Objects.requireNonNull(imgr)</b>
<b class="fc">&nbsp;                  .modulo(integerOperands.get(0), integerOperands.get(1));</b>
&nbsp;            }
<b class="fc">&nbsp;          } catch (Exception e) {</b>
<b class="fc">&nbsp;            throw new ParserException(&quot;Operands for &quot; + operator + &quot;need to be of integer type&quot;);</b>
&nbsp;          }
&nbsp;        } else {
<b class="fc">&nbsp;          throw new ParserException(operator + &quot; takes two integer operands as input. &quot;);</b>
&nbsp;        }
&nbsp;      case &quot;*&quot;:
<b class="fc">&nbsp;        if (operands.size() == 2) {</b>
&nbsp;          try {
<b class="fc">&nbsp;            if (operands.stream().anyMatch(c -&gt; c instanceof RationalFormula)) {</b>
<b class="fc">&nbsp;              List&lt;NumeralFormula&gt; numeralOperands =</b>
<b class="fc">&nbsp;                  operands.stream().map(e -&gt; (NumeralFormula) e).collect(Collectors.toList());</b>
<b class="fc">&nbsp;              return Objects.requireNonNull(rmgr)</b>
<b class="fc">&nbsp;                  .multiply(numeralOperands.get(0), numeralOperands.get(1));</b>
&nbsp;            } else {
<b class="fc">&nbsp;              List&lt;IntegerFormula&gt; integerOperands =</b>
<b class="fc">&nbsp;                  operands.stream().map(e -&gt; (IntegerFormula) e).collect(Collectors.toList());</b>
<b class="fc">&nbsp;              return Objects.requireNonNull(imgr)</b>
<b class="fc">&nbsp;                  .multiply(integerOperands.get(0), integerOperands.get(1));</b>
&nbsp;            }
<b class="fc">&nbsp;          } catch (Exception e) {</b>
<b class="fc">&nbsp;            throw new ParserException(&quot;Operands for &quot; + operator + &quot;need to be of numeral type&quot;);</b>
&nbsp;          }
&nbsp;        } else {
<b class="fc">&nbsp;          throw new ParserException(operator + &quot; takes two numeral operands as input. &quot;);</b>
&nbsp;        }
&nbsp;      case &quot;distinct&quot;:
<b class="pc">&nbsp;        if (!operands.isEmpty()) {</b>
&nbsp;          try {
<b class="fc">&nbsp;            if (operands.stream().anyMatch(c -&gt; c instanceof RationalFormula)) {</b>
<b class="fc">&nbsp;              List&lt;NumeralFormula&gt; numeralOperands =</b>
<b class="fc">&nbsp;                  operands.stream().map(e -&gt; (NumeralFormula) e).collect(Collectors.toList());</b>
<b class="fc">&nbsp;              return Objects.requireNonNull(rmgr).distinct(numeralOperands);</b>
&nbsp;            } else {
<b class="fc">&nbsp;              List&lt;IntegerFormula&gt; integerOperands =</b>
<b class="fc">&nbsp;                  operands.stream().map(e -&gt; (IntegerFormula) e).collect(Collectors.toList());</b>
<b class="fc">&nbsp;              return Objects.requireNonNull(imgr).distinct(integerOperands);</b>
&nbsp;            }
<b class="fc">&nbsp;          } catch (Exception e) {</b>
<b class="fc">&nbsp;            throw new ParserException(&quot;Operands for &quot; + operator + &quot;need to be of numeral type&quot;);</b>
&nbsp;          }
&nbsp;        } else {
<b class="nc">&nbsp;          throw new ParserException(operator + &quot; takes at least one numeral operand as input. &quot;);</b>
&nbsp;        }
&nbsp;      case &quot;&gt;&quot;:
<b class="fc">&nbsp;        if (operands.size() == 2) {</b>
&nbsp;          try {
<b class="fc">&nbsp;            if (operands.stream().anyMatch(c -&gt; c instanceof RationalFormula)) {</b>
<b class="fc">&nbsp;              List&lt;NumeralFormula&gt; numeralOperands =</b>
<b class="fc">&nbsp;                  operands.stream().map(e -&gt; (NumeralFormula) e).collect(Collectors.toList());</b>
<b class="fc">&nbsp;              return Objects.requireNonNull(rmgr)</b>
<b class="fc">&nbsp;                  .greaterThan(numeralOperands.get(0), numeralOperands.get(1));</b>
&nbsp;            } else {
<b class="fc">&nbsp;              List&lt;IntegerFormula&gt; integerOperands =</b>
<b class="fc">&nbsp;                  operands.stream().map(e -&gt; (IntegerFormula) e).collect(Collectors.toList());</b>
<b class="fc">&nbsp;              return Objects.requireNonNull(imgr)</b>
<b class="fc">&nbsp;                  .greaterThan(integerOperands.get(0), integerOperands.get(1));</b>
&nbsp;            }
<b class="fc">&nbsp;          } catch (Exception e) {</b>
<b class="fc">&nbsp;            throw new ParserException(&quot;Operands for &quot; + operator + &quot;need to be of numeral type&quot;);</b>
&nbsp;          }
&nbsp;        } else {
<b class="fc">&nbsp;          throw new ParserException(operator + &quot; takes two numeral operands as input. &quot;);</b>
&nbsp;        }
&nbsp;      case &quot;&gt;=&quot;:
<b class="fc">&nbsp;        if (operands.size() == 2) {</b>
&nbsp;          try {
<b class="fc">&nbsp;            if (operands.stream().anyMatch(c -&gt; c instanceof RationalFormula)) {</b>
<b class="fc">&nbsp;              List&lt;NumeralFormula&gt; numeralOperands =</b>
<b class="fc">&nbsp;                  operands.stream().map(e -&gt; (NumeralFormula) e).collect(Collectors.toList());</b>
<b class="fc">&nbsp;              return Objects.requireNonNull(rmgr)</b>
<b class="fc">&nbsp;                  .greaterOrEquals(numeralOperands.get(0), numeralOperands.get(1));</b>
&nbsp;            } else {
<b class="fc">&nbsp;              List&lt;IntegerFormula&gt; integerOperands =</b>
<b class="fc">&nbsp;                  operands.stream().map(e -&gt; (IntegerFormula) e).collect(Collectors.toList());</b>
<b class="fc">&nbsp;              return Objects.requireNonNull(imgr)</b>
<b class="fc">&nbsp;                  .greaterOrEquals(integerOperands.get(0), integerOperands.get(1));</b>
&nbsp;            }
<b class="fc">&nbsp;          } catch (Exception e) {</b>
<b class="fc">&nbsp;            throw new ParserException(&quot;Operands for &quot; + operator + &quot;need to be of numeral type&quot;);</b>
&nbsp;          }
&nbsp;        } else {
<b class="fc">&nbsp;          throw new ParserException(operator + &quot; takes two numeral operands as input. &quot;);</b>
&nbsp;        }
&nbsp;      case &quot;&lt;&quot;:
<b class="fc">&nbsp;        if (operands.size() == 2) {</b>
&nbsp;          try {
<b class="fc">&nbsp;            if (operands.stream().anyMatch(c -&gt; c instanceof RationalFormula)) {</b>
<b class="fc">&nbsp;              List&lt;NumeralFormula&gt; numeralOperands =</b>
<b class="fc">&nbsp;                  operands.stream().map(e -&gt; (NumeralFormula) e).collect(Collectors.toList());</b>
<b class="fc">&nbsp;              return Objects.requireNonNull(rmgr)</b>
<b class="fc">&nbsp;                  .lessThan(numeralOperands.get(0), numeralOperands.get(1));</b>
&nbsp;            } else {
<b class="fc">&nbsp;              List&lt;IntegerFormula&gt; integerOperands =</b>
<b class="fc">&nbsp;                  operands.stream().map(e -&gt; (IntegerFormula) e).collect(Collectors.toList());</b>
<b class="fc">&nbsp;              return Objects.requireNonNull(imgr)</b>
<b class="fc">&nbsp;                  .lessThan(integerOperands.get(0), integerOperands.get(1));</b>
&nbsp;            }
<b class="fc">&nbsp;          } catch (Exception e) {</b>
<b class="fc">&nbsp;            throw new ParserException(&quot;Operands for &quot; + operator + &quot;need to be of numeral type&quot;);</b>
&nbsp;          }
&nbsp;        } else {
<b class="fc">&nbsp;          throw new ParserException(operator + &quot; takes two numeral operands as input. &quot;);</b>
&nbsp;        }
&nbsp;      case &quot;&lt;=&quot;:
<b class="fc">&nbsp;        if (operands.size() == 2) {</b>
&nbsp;          try {
<b class="fc">&nbsp;            if (operands.stream().anyMatch(c -&gt; c instanceof RationalFormula)) {</b>
<b class="fc">&nbsp;              List&lt;NumeralFormula&gt; numeralOperands =</b>
<b class="fc">&nbsp;                  operands.stream().map(e -&gt; (NumeralFormula) e).collect(Collectors.toList());</b>
<b class="fc">&nbsp;              return Objects.requireNonNull(rmgr)</b>
<b class="fc">&nbsp;                  .lessOrEquals(numeralOperands.get(0), numeralOperands.get(1));</b>
&nbsp;            } else {
<b class="fc">&nbsp;              List&lt;IntegerFormula&gt; integerOperands =</b>
<b class="fc">&nbsp;                  operands.stream().map(e -&gt; (IntegerFormula) e).collect(Collectors.toList());</b>
<b class="fc">&nbsp;              return Objects.requireNonNull(imgr)</b>
<b class="fc">&nbsp;                  .lessOrEquals(integerOperands.get(0), integerOperands.get(1));</b>
&nbsp;            }
<b class="fc">&nbsp;          } catch (Exception e) {</b>
<b class="fc">&nbsp;            throw new ParserException(&quot;Operands for &quot; + operator + &quot;need to be of numeral type&quot;);</b>
&nbsp;          }
&nbsp;        } else {
<b class="fc">&nbsp;          throw new ParserException(operator + &quot; takes two numeral operands as input. &quot;);</b>
&nbsp;        }
&nbsp;
&nbsp;      case &quot;to_int&quot;:
<b class="fc">&nbsp;        if (operands.size() == 1) {</b>
&nbsp;          try {
<b class="fc">&nbsp;            List&lt;NumeralFormula&gt; numeralOperands =</b>
<b class="fc">&nbsp;                operands.stream().map(e -&gt; (NumeralFormula) e).collect(Collectors.toList());</b>
<b class="fc">&nbsp;            return Objects.requireNonNull(rmgr).floor(numeralOperands.get(0));</b>
<b class="fc">&nbsp;          } catch (Exception e) {</b>
<b class="fc">&nbsp;            throw new ParserException(&quot;Operands for &quot; + operator + &quot;need to be of real type&quot;);</b>
&nbsp;          }
&nbsp;        } else {
<b class="fc">&nbsp;          throw new ParserException(operator + &quot; takes one real operands as input. &quot;);</b>
&nbsp;        }
&nbsp;
&nbsp;        // BitVec operators
&nbsp;      case &quot;bvneg&quot;:
<b class="fc">&nbsp;        if (operands.size() != 1) {</b>
<b class="fc">&nbsp;          throw new ParserException(operator + &quot; takes one bitvector operand as input.&quot;);</b>
&nbsp;        } else {
&nbsp;          try {
<b class="fc">&nbsp;            return Objects.requireNonNull(bimgr).negate((BitvectorFormula) operands.get(0));</b>
<b class="fc">&nbsp;          } catch (Exception e) {</b>
<b class="fc">&nbsp;            throw new ParserException(&quot;Operands for &quot; + operator + &quot;need to be of bitvector type&quot;);</b>
&nbsp;          }
&nbsp;        }
&nbsp;      case &quot;bvadd&quot;:
<b class="fc">&nbsp;        if (operands.size() != 2) {</b>
<b class="fc">&nbsp;          throw new ParserException(operator + &quot; takes two bitvector operand as input.&quot;);</b>
&nbsp;        } else {
&nbsp;          try {
<b class="fc">&nbsp;            return Objects.requireNonNull(bimgr)</b>
<b class="fc">&nbsp;                .add((BitvectorFormula) operands.get(0), (BitvectorFormula) operands.get(1));</b>
<b class="fc">&nbsp;          } catch (Exception e) {</b>
<b class="fc">&nbsp;            throw new ParserException(&quot;Operands for &quot; + operator + &quot; need to be of bitvector type&quot;);</b>
&nbsp;          }
&nbsp;        }
&nbsp;      case &quot;bvsub&quot;:
<b class="fc">&nbsp;        if (operands.size() != 2) {</b>
<b class="fc">&nbsp;          throw new ParserException(operator + &quot; takes two bitvector operand as input.&quot;);</b>
&nbsp;        } else {
&nbsp;          try {
<b class="fc">&nbsp;            return Objects.requireNonNull(bimgr)</b>
<b class="fc">&nbsp;                .subtract((BitvectorFormula) operands.get(0), (BitvectorFormula) operands.get(1));</b>
<b class="fc">&nbsp;          } catch (Exception e) {</b>
<b class="fc">&nbsp;            throw new ParserException(&quot;Operands for &quot; + operator + &quot;need to be of bitvector type&quot;);</b>
&nbsp;          }
&nbsp;        }
&nbsp;      case &quot;bvsdiv&quot;:
<b class="fc">&nbsp;        if (operands.size() != 2) {</b>
<b class="fc">&nbsp;          throw new ParserException(operator + &quot; takes two bitvector operand as input.&quot;);</b>
&nbsp;        } else {
&nbsp;          try {
<b class="fc">&nbsp;            return Objects.requireNonNull(bimgr)</b>
<b class="fc">&nbsp;                .divide(</b>
<b class="fc">&nbsp;                    (BitvectorFormula) operands.get(0), (BitvectorFormula) operands.get(1), true);</b>
<b class="fc">&nbsp;          } catch (Exception e) {</b>
<b class="fc">&nbsp;            throw new ParserException(&quot;Operands for &quot; + operator + &quot;need to be of bitvector type&quot;);</b>
&nbsp;          }
&nbsp;        }
&nbsp;      case &quot;bvudiv&quot;:
<b class="fc">&nbsp;        if (operands.size() != 2) {</b>
<b class="fc">&nbsp;          throw new ParserException(operator + &quot; takes two bitvector operand as input.&quot;);</b>
&nbsp;        } else {
&nbsp;          try {
<b class="fc">&nbsp;            return Objects.requireNonNull(bimgr)</b>
<b class="fc">&nbsp;                .divide(</b>
<b class="fc">&nbsp;                    (BitvectorFormula) operands.get(0), (BitvectorFormula) operands.get(1), false);</b>
<b class="fc">&nbsp;          } catch (Exception e) {</b>
<b class="fc">&nbsp;            throw new ParserException(&quot;Operands for &quot; + operator + &quot;need to be of bitvector type&quot;);</b>
&nbsp;          }
&nbsp;        }
&nbsp;      case &quot;bvsrem&quot;:
<b class="fc">&nbsp;        if (operands.size() != 2) {</b>
<b class="fc">&nbsp;          throw new ParserException(operator + &quot; takes two bitvector operand as input.&quot;);</b>
&nbsp;        } else {
&nbsp;          try {
<b class="fc">&nbsp;            return Objects.requireNonNull(bimgr)</b>
<b class="fc">&nbsp;                .modulo(</b>
<b class="fc">&nbsp;                    (BitvectorFormula) operands.get(0), (BitvectorFormula) operands.get(1), true);</b>
<b class="fc">&nbsp;          } catch (Exception e) {</b>
<b class="fc">&nbsp;            throw new ParserException(&quot;Operands for &quot; + operator + &quot;need to be of bitvector type&quot;);</b>
&nbsp;          }
&nbsp;        }
&nbsp;      case &quot;bvurem&quot;:
<b class="fc">&nbsp;        if (operands.size() != 2) {</b>
<b class="fc">&nbsp;          throw new ParserException(operator + &quot; takes two bitvector operand as input.&quot;);</b>
&nbsp;        } else {
&nbsp;          try {
<b class="fc">&nbsp;            return Objects.requireNonNull(bimgr)</b>
<b class="fc">&nbsp;                .modulo(</b>
<b class="fc">&nbsp;                    (BitvectorFormula) operands.get(0), (BitvectorFormula) operands.get(1), false);</b>
<b class="fc">&nbsp;          } catch (Exception e) {</b>
<b class="fc">&nbsp;            throw new ParserException(&quot;Operands for &quot; + operator + &quot;need to be of bitvector type&quot;);</b>
&nbsp;          }
&nbsp;        }
&nbsp;      case &quot;bvmul&quot;:
<b class="fc">&nbsp;        if (operands.size() != 2) {</b>
<b class="fc">&nbsp;          throw new ParserException(operator + &quot; takes two bitvector operand as input.&quot;);</b>
&nbsp;        } else {
&nbsp;          try {
<b class="fc">&nbsp;            return Objects.requireNonNull(bimgr)</b>
<b class="fc">&nbsp;                .multiply((BitvectorFormula) operands.get(0), (BitvectorFormula) operands.get(1));</b>
<b class="fc">&nbsp;          } catch (Exception e) {</b>
<b class="fc">&nbsp;            throw new ParserException(&quot;Operands for &quot; + operator + &quot;need to be of bitvector type&quot;);</b>
&nbsp;          }
&nbsp;        }
&nbsp;      case &quot;bvsgt&quot;:
<b class="fc">&nbsp;        if (operands.size() != 2) {</b>
<b class="fc">&nbsp;          throw new ParserException(operator + &quot; takes two bitvector operand as input.&quot;);</b>
&nbsp;        } else {
&nbsp;          try {
<b class="fc">&nbsp;            return Objects.requireNonNull(bimgr)</b>
<b class="fc">&nbsp;                .greaterThan(</b>
<b class="fc">&nbsp;                    (BitvectorFormula) operands.get(0), (BitvectorFormula) operands.get(1), true);</b>
<b class="fc">&nbsp;          } catch (Exception e) {</b>
<b class="fc">&nbsp;            throw new ParserException(&quot;Operands for &quot; + operator + &quot;need to be of bitvector type&quot;);</b>
&nbsp;          }
&nbsp;        }
&nbsp;      case &quot;bvugt&quot;:
<b class="fc">&nbsp;        if (operands.size() != 2) {</b>
<b class="fc">&nbsp;          throw new ParserException(operator + &quot; takes two bitvector operand as input.&quot;);</b>
&nbsp;        } else {
&nbsp;          try {
<b class="fc">&nbsp;            return Objects.requireNonNull(bimgr)</b>
<b class="fc">&nbsp;                .greaterThan(</b>
<b class="fc">&nbsp;                    (BitvectorFormula) operands.get(0), (BitvectorFormula) operands.get(1), false);</b>
<b class="fc">&nbsp;          } catch (Exception e) {</b>
<b class="fc">&nbsp;            throw new ParserException(&quot;Operands for &quot; + operator + &quot;need to be of bitvector type&quot;);</b>
&nbsp;          }
&nbsp;        }
&nbsp;      case &quot;bvsge&quot;:
<b class="fc">&nbsp;        if (operands.size() != 2) {</b>
<b class="fc">&nbsp;          throw new ParserException(operator + &quot; takes two bitvector operand as input.&quot;);</b>
&nbsp;        } else {
&nbsp;          try {
<b class="fc">&nbsp;            return Objects.requireNonNull(bimgr)</b>
<b class="fc">&nbsp;                .greaterOrEquals(</b>
<b class="fc">&nbsp;                    (BitvectorFormula) operands.get(0), (BitvectorFormula) operands.get(1), true);</b>
<b class="fc">&nbsp;          } catch (Exception e) {</b>
<b class="fc">&nbsp;            throw new ParserException(&quot;Operands for &quot; + operator + &quot;need to be of bitvector type&quot;);</b>
&nbsp;          }
&nbsp;        }
&nbsp;      case &quot;bvuge&quot;:
<b class="fc">&nbsp;        if (operands.size() != 2) {</b>
<b class="fc">&nbsp;          throw new ParserException(operator + &quot; takes two bitvector operand as input.&quot;);</b>
&nbsp;        } else {
&nbsp;          try {
<b class="fc">&nbsp;            return Objects.requireNonNull(bimgr)</b>
<b class="fc">&nbsp;                .greaterOrEquals(</b>
<b class="fc">&nbsp;                    (BitvectorFormula) operands.get(0), (BitvectorFormula) operands.get(1), false);</b>
<b class="fc">&nbsp;          } catch (Exception e) {</b>
<b class="fc">&nbsp;            throw new ParserException(&quot;Operands for &quot; + operator + &quot;need to be of bitvector type&quot;);</b>
&nbsp;          }
&nbsp;        }
&nbsp;      case &quot;bvslt&quot;:
<b class="fc">&nbsp;        if (operands.size() != 2) {</b>
<b class="fc">&nbsp;          throw new ParserException(operator + &quot; takes two bitvector operand as input.&quot;);</b>
&nbsp;        } else {
&nbsp;          try {
<b class="fc">&nbsp;            return Objects.requireNonNull(bimgr)</b>
<b class="fc">&nbsp;                .lessThan(</b>
<b class="fc">&nbsp;                    (BitvectorFormula) operands.get(0), (BitvectorFormula) operands.get(1), true);</b>
<b class="fc">&nbsp;          } catch (Exception e) {</b>
<b class="fc">&nbsp;            throw new ParserException(&quot;Operands for &quot; + operator + &quot;need to be of bitvector type&quot;);</b>
&nbsp;          }
&nbsp;        }
&nbsp;      case &quot;bvult&quot;:
<b class="fc">&nbsp;        if (operands.size() != 2) {</b>
<b class="fc">&nbsp;          throw new ParserException(operator + &quot; takes two bitvector operand as input.&quot;);</b>
&nbsp;        } else {
&nbsp;          try {
<b class="fc">&nbsp;            return Objects.requireNonNull(bimgr)</b>
<b class="fc">&nbsp;                .lessThan(</b>
<b class="fc">&nbsp;                    (BitvectorFormula) operands.get(0), (BitvectorFormula) operands.get(1), false);</b>
<b class="fc">&nbsp;          } catch (Exception e) {</b>
<b class="fc">&nbsp;            throw new ParserException(&quot;Operands for &quot; + operator + &quot;need to be of bitvector type&quot;);</b>
&nbsp;          }
&nbsp;        }
&nbsp;      case &quot;bvsle&quot;:
<b class="fc">&nbsp;        if (operands.size() != 2) {</b>
<b class="fc">&nbsp;          throw new ParserException(operator + &quot; takes two bitvector operand as input.&quot;);</b>
&nbsp;        } else {
&nbsp;          try {
<b class="fc">&nbsp;            return Objects.requireNonNull(bimgr)</b>
<b class="fc">&nbsp;                .lessOrEquals(</b>
<b class="fc">&nbsp;                    (BitvectorFormula) operands.get(0), (BitvectorFormula) operands.get(1), true);</b>
<b class="fc">&nbsp;          } catch (Exception e) {</b>
<b class="fc">&nbsp;            throw new ParserException(&quot;Operands for &quot; + operator + &quot;need to be of bitvector type&quot;);</b>
&nbsp;          }
&nbsp;        }
&nbsp;      case &quot;bvule&quot;:
<b class="fc">&nbsp;        if (operands.size() != 2) {</b>
<b class="fc">&nbsp;          throw new ParserException(operator + &quot; takes two bitvector operand as input.&quot;);</b>
&nbsp;        } else {
&nbsp;          try {
<b class="fc">&nbsp;            return Objects.requireNonNull(bimgr)</b>
<b class="fc">&nbsp;                .lessOrEquals(</b>
<b class="fc">&nbsp;                    (BitvectorFormula) operands.get(0), (BitvectorFormula) operands.get(1), false);</b>
<b class="fc">&nbsp;          } catch (Exception e) {</b>
<b class="fc">&nbsp;            throw new ParserException(&quot;Operands for &quot; + operator + &quot;need to be of bitvector type&quot;);</b>
&nbsp;          }
&nbsp;        }
&nbsp;      case &quot;bvnot&quot;:
<b class="fc">&nbsp;        if (operands.size() != 1) {</b>
<b class="fc">&nbsp;          throw new ParserException(operator + &quot; takes one bitvector operand as input.&quot;);</b>
&nbsp;        } else {
&nbsp;          try {
<b class="fc">&nbsp;            return Objects.requireNonNull(bimgr).not((BitvectorFormula) operands.get(0));</b>
<b class="fc">&nbsp;          } catch (Exception e) {</b>
<b class="fc">&nbsp;            throw new ParserException(&quot;Operands for &quot; + operator + &quot;need to be of bitvector type&quot;);</b>
&nbsp;          }
&nbsp;        }
&nbsp;      case &quot;bvand&quot;:
<b class="fc">&nbsp;        if (operands.size() != 2) {</b>
<b class="fc">&nbsp;          throw new ParserException(operator + &quot; takes two bitvector operand as input.&quot;);</b>
&nbsp;        } else {
&nbsp;          try {
<b class="fc">&nbsp;            return Objects.requireNonNull(bimgr)</b>
<b class="fc">&nbsp;                .and((BitvectorFormula) operands.get(0), (BitvectorFormula) operands.get(1));</b>
<b class="fc">&nbsp;          } catch (Exception e) {</b>
<b class="fc">&nbsp;            throw new ParserException(&quot;Operands for &quot; + operator + &quot;need to be of bitvector type&quot;);</b>
&nbsp;          }
&nbsp;        }
&nbsp;      case &quot;bvor&quot;:
<b class="fc">&nbsp;        if (operands.size() != 2) {</b>
<b class="fc">&nbsp;          throw new ParserException(operator + &quot; takes two bitvector operand as input.&quot;);</b>
&nbsp;        } else {
&nbsp;          try {
<b class="fc">&nbsp;            return Objects.requireNonNull(bimgr)</b>
<b class="fc">&nbsp;                .or((BitvectorFormula) operands.get(0), (BitvectorFormula) operands.get(1));</b>
<b class="fc">&nbsp;          } catch (Exception e) {</b>
<b class="fc">&nbsp;            throw new ParserException(&quot;Operands for &quot; + operator + &quot;need to be of bitvector type&quot;);</b>
&nbsp;          }
&nbsp;        }
&nbsp;      case &quot;bvxor&quot;:
<b class="fc">&nbsp;        if (operands.size() != 2) {</b>
<b class="fc">&nbsp;          throw new ParserException(operator + &quot; takes two bitvector operand as input.&quot;);</b>
&nbsp;        } else {
&nbsp;          try {
<b class="fc">&nbsp;            return Objects.requireNonNull(bimgr)</b>
<b class="fc">&nbsp;                .xor((BitvectorFormula) operands.get(0), (BitvectorFormula) operands.get(1));</b>
<b class="fc">&nbsp;          } catch (Exception e) {</b>
<b class="fc">&nbsp;            throw new ParserException(&quot;Operands for &quot; + operator + &quot;need to be of bitvector type&quot;);</b>
&nbsp;          }
&nbsp;        }
&nbsp;      case &quot;bvashr&quot;:
<b class="fc">&nbsp;        if (operands.size() != 2) {</b>
<b class="fc">&nbsp;          throw new ParserException(operator + &quot; takes two bitvector operand as input.&quot;);</b>
&nbsp;        } else {
&nbsp;          try {
<b class="fc">&nbsp;            return Objects.requireNonNull(bimgr)</b>
<b class="fc">&nbsp;                .shiftRight(</b>
<b class="fc">&nbsp;                    (BitvectorFormula) operands.get(0), (BitvectorFormula) operands.get(1), true);</b>
<b class="fc">&nbsp;          } catch (Exception e) {</b>
<b class="fc">&nbsp;            throw new ParserException(&quot;Operands for &quot; + operator + &quot;need to be of bitvector type&quot;);</b>
&nbsp;          }
&nbsp;        }
&nbsp;      case &quot;bvlshr&quot;:
<b class="fc">&nbsp;        if (operands.size() != 2) {</b>
<b class="fc">&nbsp;          throw new ParserException(operator + &quot; takes two bitvector operand as input.&quot;);</b>
&nbsp;        } else {
&nbsp;          try {
<b class="fc">&nbsp;            return Objects.requireNonNull(bimgr)</b>
<b class="fc">&nbsp;                .shiftRight(</b>
<b class="fc">&nbsp;                    (BitvectorFormula) operands.get(0), (BitvectorFormula) operands.get(1), false);</b>
<b class="fc">&nbsp;          } catch (Exception e) {</b>
<b class="fc">&nbsp;            throw new ParserException(&quot;Operands for &quot; + operator + &quot;need to be of bitvector type&quot;);</b>
&nbsp;          }
&nbsp;        }
&nbsp;      case &quot;bvshl&quot;:
<b class="fc">&nbsp;        if (operands.size() != 2) {</b>
<b class="fc">&nbsp;          throw new ParserException(operator + &quot; takes two bitvector operand as input.&quot;);</b>
&nbsp;        } else {
&nbsp;          try {
<b class="fc">&nbsp;            return Objects.requireNonNull(bimgr)</b>
<b class="fc">&nbsp;                .shiftLeft((BitvectorFormula) operands.get(0), (BitvectorFormula) operands.get(1));</b>
<b class="fc">&nbsp;          } catch (Exception e) {</b>
<b class="fc">&nbsp;            throw new ParserException(&quot;Operands for &quot; + operator + &quot;need to be of bitvector type&quot;);</b>
&nbsp;          }
&nbsp;        }
&nbsp;      case &quot;concat&quot;:
<b class="fc">&nbsp;        if (operands.size() != 2) {</b>
<b class="fc">&nbsp;          throw new ParserException(operator + &quot; takes two bitvector operand as input.&quot;);</b>
&nbsp;        } else {
&nbsp;          try {
<b class="fc">&nbsp;            return Objects.requireNonNull(bimgr)</b>
<b class="fc">&nbsp;                .concat((BitvectorFormula) operands.get(0), (BitvectorFormula) operands.get(1));</b>
<b class="fc">&nbsp;          } catch (Exception e) {</b>
<b class="fc">&nbsp;            throw new ParserException(&quot;Operands for &quot; + operator + &quot;need to be of bitvector type&quot;);</b>
&nbsp;          }
&nbsp;        }
&nbsp;      case &quot;extract&quot;:
<b class="pc">&nbsp;        if (operands.size() == 1) {</b>
<b class="fc">&nbsp;          if (Objects.requireNonNull(operators).size() == 3</b>
<b class="fc">&nbsp;              &amp;&amp; isInteger(operators.get(2))</b>
<b class="pc">&nbsp;              &amp;&amp; isInteger(operators.get(1))) {</b>
<b class="fc">&nbsp;            int right = Integer.parseInt(operators.get(2));</b>
<b class="fc">&nbsp;            int left = Integer.parseInt(operators.get(1));</b>
&nbsp;            try {
<b class="fc">&nbsp;              return Objects.requireNonNull(bimgr)</b>
<b class="fc">&nbsp;                  .extract((BitvectorFormula) operands.get(0), left, right);</b>
<b class="fc">&nbsp;            } catch (Exception e) {</b>
<b class="fc">&nbsp;              throw new ParserException(</b>
&nbsp;                  &quot;Operands for &quot; + operator + &quot;need to be of bitvector type&quot;);
&nbsp;            }
&nbsp;          } else {
<b class="fc">&nbsp;            throw new ParserException(</b>
&nbsp;                operator + &quot; takes one bitvector and two integers as input. &quot;);
&nbsp;          }
&nbsp;        } else {
<b class="nc">&nbsp;          throw new ParserException(</b>
&nbsp;              operator + &quot; takes one bitvector and two integers as &quot; + &quot;input.&quot;);
&nbsp;        }
&nbsp;      case &quot;zero_extend&quot;:
<b class="pc">&nbsp;        if (operands.size() == 1) {</b>
<b class="fc">&nbsp;          if (Objects.requireNonNull(operators).size() == 2 &amp;&amp; isInteger(operators.get(1))) {</b>
<b class="fc">&nbsp;            int extension = Integer.parseInt(operators.get(1));</b>
&nbsp;            try {
<b class="fc">&nbsp;              return Objects.requireNonNull(bimgr)</b>
<b class="fc">&nbsp;                  .extend((BitvectorFormula) operands.get(0), extension, false);</b>
<b class="fc">&nbsp;            } catch (Exception e) {</b>
<b class="fc">&nbsp;              throw new ParserException(</b>
&nbsp;                  &quot;Operands for &quot; + operator + &quot;need to be of bitvector type&quot;);
&nbsp;            }
&nbsp;          } else {
<b class="fc">&nbsp;            throw new ParserException(operator + &quot; takes one bitvector and one integer as input. &quot;);</b>
&nbsp;          }
&nbsp;        } else {
<b class="nc">&nbsp;          throw new ParserException(operator + &quot; takes one bitvector and one integer as input.&quot;);</b>
&nbsp;        }
&nbsp;      case &quot;sign_extend&quot;:
<b class="pc">&nbsp;        if (operands.size() == 1) {</b>
<b class="fc">&nbsp;          if (Objects.requireNonNull(operators).size() == 2 &amp;&amp; isInteger(operators.get(1))) {</b>
<b class="fc">&nbsp;            int extension = Integer.parseInt(operators.get(1));</b>
&nbsp;            try {
<b class="fc">&nbsp;              return Objects.requireNonNull(bimgr)</b>
<b class="fc">&nbsp;                  .extend((BitvectorFormula) operands.get(0), extension, true);</b>
<b class="fc">&nbsp;            } catch (Exception e) {</b>
<b class="fc">&nbsp;              throw new ParserException(</b>
&nbsp;                  &quot;Operands for &quot; + operator + &quot;need to be of bitvector type&quot;);
&nbsp;            }
&nbsp;          } else {
<b class="fc">&nbsp;            throw new ParserException(operator + &quot; takes one bitvector and one integer as input. &quot;);</b>
&nbsp;          }
&nbsp;        } else {
<b class="nc">&nbsp;          throw new ParserException(operator + &quot; takes one bitvector and one integer as input.&quot;);</b>
&nbsp;        }
&nbsp;      case &quot;bv2int&quot;:
<b class="fc">&nbsp;        if (operands.size() != 1) {</b>
<b class="fc">&nbsp;          throw new ParserException(operator + &quot; takes one bitvector operand as input.&quot;);</b>
&nbsp;        } else {
&nbsp;          try {
<b class="fc">&nbsp;            return Objects.requireNonNull(bimgr)</b>
<b class="fc">&nbsp;                .toIntegerFormula((BitvectorFormula) operands.get(0), false);</b>
<b class="fc">&nbsp;          } catch (Exception e) {</b>
<b class="fc">&nbsp;            throw new ParserException(&quot;Operands for &quot; + operator + &quot; need to be of bitvector type&quot;);</b>
&nbsp;          }
&nbsp;        }
&nbsp;      case &quot;int2bv&quot;:
&nbsp;      case &quot;rotate_left&quot;:
&nbsp;      case &quot;rotate_right&quot;:
&nbsp;      case &quot;repeat&quot;:
<b class="fc">&nbsp;        throw new ParserException(operator + &quot; is not available in JavaSMT&quot;);</b>
&nbsp;
&nbsp;        // array operators
&nbsp;      case &quot;select&quot;:
<b class="fc">&nbsp;        if (operands.size() == 2) {</b>
&nbsp;          try {
<b class="fc">&nbsp;            return Objects.requireNonNull(amgr)</b>
<b class="fc">&nbsp;                .select((ArrayFormula&lt;Formula, Formula&gt;) operands.get(0), operands.get(1));</b>
<b class="fc">&nbsp;          } catch (Exception e) {</b>
<b class="fc">&nbsp;            throw new ParserException(&quot;Operands for &quot; + operator + &quot; need to be of Array type&quot;);</b>
&nbsp;          }
&nbsp;        } else {
<b class="fc">&nbsp;          throw new ParserException(operator + &quot; takes one array and one index as input. &quot;);</b>
&nbsp;        }
&nbsp;      case &quot;store&quot;:
<b class="pc">&nbsp;        if (operands.size() == 3) {</b>
&nbsp;          try {
<b class="fc">&nbsp;          return Objects.requireNonNull(amgr)</b>
<b class="fc">&nbsp;              .store(</b>
<b class="fc">&nbsp;                  (ArrayFormula&lt;Formula, Formula&gt;) operands.get(0),</b>
<b class="fc">&nbsp;                  operands.get(1),</b>
<b class="fc">&nbsp;                  operands.get(2));</b>
<b class="nc">&nbsp;          } catch (Exception e) {</b>
<b class="nc">&nbsp;            throw new ParserException(&quot;Operands for &quot; + operator + &quot; need to be of Array type&quot;);</b>
&nbsp;          }
&nbsp;        } else {
<b class="nc">&nbsp;          throw new ParserException(operator + &quot; takes one array and one index as input. &quot;);</b>
&nbsp;        }
&nbsp;      case &quot;const&quot;:
<b class="pc">&nbsp;        if (isModel) {</b>
<b class="fc">&nbsp;          variables.put(</b>
&nbsp;              &quot;temp&quot;,
&nbsp;              new ParserFormula(
<b class="fc">&nbsp;                  Objects.requireNonNull(amgr)</b>
<b class="fc">&nbsp;                      .makeArray(</b>
&nbsp;                          &quot;(as const (Array &quot;
<b class="fc">&nbsp;                              + getArrayStrings(</b>
&nbsp;                                  ((FormulaType.ArrayFormulaType&lt;?, ?&gt;)
<b class="fc">&nbsp;                                          Objects.requireNonNull(sort))</b>
<b class="fc">&nbsp;                                      .getIndexType())</b>
&nbsp;                              + &quot; &quot;
<b class="fc">&nbsp;                              + getArrayStrings(</b>
<b class="fc">&nbsp;                                  ((FormulaType.ArrayFormulaType&lt;?, ?&gt;) sort).getElementType())</b>
&nbsp;                              + &quot;) &quot;
<b class="fc">&nbsp;                              + operands.get(0)</b>
&nbsp;                              + &quot;)&quot;,
&nbsp;                          (FormulaType.ArrayFormulaType&lt;?, ?&gt;) sort)));
<b class="fc">&nbsp;          return variables.get(&quot;temp&quot;).javaSmt;</b>
&nbsp;        } else {
<b class="nc">&nbsp;          throw new ParserException(&quot;\&quot;as const\&quot; is not supported by JavaSMT&quot;);</b>
&nbsp;        }
&nbsp;        // UF
&nbsp;      case &quot;UF&quot;:
&nbsp;        try {
<b class="fc">&nbsp;          return umgr.callUF(</b>
<b class="fc">&nbsp;              (FunctionDeclaration&lt;? extends Formula&gt;) Objects.requireNonNull(ufOperator),</b>
&nbsp;              operands);
<b class="nc">&nbsp;        } catch (Exception e) {</b>
<b class="nc">&nbsp;          throw new ParserException(operator + &quot; takes one array and one index as input. &quot;);</b>
&nbsp;        }
&nbsp;
&nbsp;        // overloaded operators
&nbsp;      case &quot;=&quot;:
<b class="pc">&nbsp;        if (operands.size() == 2) {</b>
&nbsp;          try {
<b class="fc">&nbsp;            if (operands.stream().anyMatch(c -&gt; c instanceof ArrayFormula)) {</b>
<b class="fc">&nbsp;              return Objects.requireNonNull(amgr)</b>
<b class="fc">&nbsp;                  .equivalence(</b>
<b class="fc">&nbsp;                      (ArrayFormula&lt;Formula, Formula&gt;) operands.get(0),</b>
<b class="fc">&nbsp;                      (ArrayFormula&lt;Formula, Formula&gt;) operands.get(1));</b>
<b class="fc">&nbsp;            } else if (operands.stream().anyMatch(c -&gt; c instanceof RationalFormula)) {</b>
&nbsp;              // if (operands.stream().anyMatch(c -&gt; variables.containsKey(c)))
<b class="fc">&nbsp;              return Objects.requireNonNull(rmgr)</b>
<b class="fc">&nbsp;                  .equal((NumeralFormula) operands.get(0), (NumeralFormula) operands.get(1));</b>
<b class="fc">&nbsp;            } else if (operands.stream().anyMatch(c -&gt; c instanceof IntegerFormula)) {</b>
<b class="fc">&nbsp;              return Objects.requireNonNull(imgr)</b>
<b class="fc">&nbsp;                  .equal((IntegerFormula) operands.get(0), (IntegerFormula) operands.get(1));</b>
<b class="fc">&nbsp;            } else if (operands.stream().anyMatch(c -&gt; c instanceof BooleanFormula)) {</b>
<b class="fc">&nbsp;              return bmgr.equivalence(</b>
<b class="fc">&nbsp;                  (BooleanFormula) operands.get(0), (BooleanFormula) operands.get(1));</b>
<b class="pc">&nbsp;            } else if (operands.stream().anyMatch(c -&gt; c instanceof BitvectorFormula)) {</b>
<b class="fc">&nbsp;              BooleanFormula result =</b>
<b class="fc">&nbsp;                  Objects.requireNonNull(bimgr)</b>
<b class="fc">&nbsp;                      .equal(</b>
<b class="fc">&nbsp;                          (BitvectorFormula) operands.get(0), (BitvectorFormula) operands.get(1));</b>
<b class="fc">&nbsp;              return result;</b>
&nbsp;            } else {
<b class="nc">&nbsp;              throw new ParserException(</b>
&nbsp;                  &quot;Operands for &quot; + operator + &quot;need to be of the same type&quot; + operands);
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;          } catch (Exception e) {</b>
<b class="nc">&nbsp;            throw new ParserException(</b>
&nbsp;                &quot;Operands for &quot; + operator + &quot;need to be of the same type&quot; + operands);
&nbsp;          }
&nbsp;        } else {
<b class="nc">&nbsp;          throw new ParserException(operator + &quot; takes two equal types of operands as input. &quot;);</b>
&nbsp;        }
&nbsp;      default:
<b class="nc">&nbsp;        throw new ParserException(&quot;Operator &quot; + operator + &quot; is not supported for operands type.&quot;);</b>
&nbsp;    }
&nbsp;  }
&nbsp;
&nbsp;  @Override
&nbsp;  public Object visitTerm_let(Term_letContext ctx) {
<b class="fc">&nbsp;    for (int i = 0; i &lt; ctx.var_binding().size(); i++) {</b>
<b class="fc">&nbsp;      visit(ctx.var_binding(i));</b>
&nbsp;    }
<b class="fc">&nbsp;    Formula formula = (Formula) visit(ctx.term());</b>
<b class="fc">&nbsp;    for (int j = 0; j &lt; ctx.var_binding().size(); j++) {</b>
<b class="fc">&nbsp;      letVariables.remove(ctx.var_binding(j).symbol().getText());</b>
&nbsp;    }
<b class="fc">&nbsp;    return formula;</b>
&nbsp;  }
&nbsp;
&nbsp;  @Override
&nbsp;  public Object visitTerm_forall(Term_forallContext ctx) {
<b class="fc">&nbsp;    throw new ParserException(&quot;Parser does not support Quantifiers&quot;);</b>
&nbsp;  }
&nbsp;
&nbsp;  @Override
&nbsp;  public Object visitTerm_exists(Term_existsContext ctx) {
<b class="fc">&nbsp;    throw new ParserException(&quot;Parser does not support Quantifiers&quot;);</b>
&nbsp;  }
&nbsp;
&nbsp;  @Override
&nbsp;  public Object visitTerm_exclam(Term_exclamContext ctx) {
<b class="fc">&nbsp;    throw new ParserException(&quot;Parser does not support Attributed Expressions&quot;);</b>
&nbsp;  }
&nbsp;
&nbsp;  @Override
&nbsp;  public Object visitFunction_def(Function_defContext ctx) {
<b class="fc">&nbsp;    String variable = replaceReservedChars(ctx.symbol().getText());</b>
&nbsp;
&nbsp;    List&lt;FormulaType&lt;?&gt;&gt; javaSorts;
<b class="fc">&nbsp;    List&lt;Formula&gt; inputParams = new ArrayList&lt;&gt;();</b>
<b class="fc">&nbsp;    if (!ctx.sorted_var().isEmpty()) {</b>
<b class="fc">&nbsp;      for (int i = 0; i &lt; ctx.sorted_var().size(); i++) {</b>
<b class="fc">&nbsp;        String name = ctx.sorted_var(i).symbol().getText();</b>
<b class="fc">&nbsp;        FormulaType&lt;?&gt; sort = (FormulaType&lt;?&gt;) visit(ctx.sorted_var(i).sort());</b>
<b class="fc">&nbsp;        Formula temp = mapKey(sort, name);</b>
<b class="fc">&nbsp;        variables.put(name, new ParserFormula(temp));</b>
<b class="fc">&nbsp;        inputParams.add(temp);</b>
&nbsp;      }
&nbsp;    }
<b class="fc">&nbsp;    javaSorts = inputParams.stream().map(fmgr::getFormulaType).collect(Collectors.toList());</b>
&nbsp;
<b class="fc">&nbsp;    FormulaType&lt;?&gt; returnTypes = (FormulaType&lt;?&gt;) visit(ctx.sort());</b>
&nbsp;
&nbsp;    Formula key;
<b class="fc">&nbsp;    Formula input = (Formula) visit(ctx.term());</b>
<b class="fc">&nbsp;    if (!inputParams.isEmpty()) {</b>
<b class="fc">&nbsp;      ParserFormula temp = new ParserFormula(umgr.declareUF(variable, returnTypes, javaSorts));</b>
<b class="fc">&nbsp;      temp.setType(&quot;UF&quot;);</b>
<b class="fc">&nbsp;      temp.setReturnType(returnTypes);</b>
<b class="fc">&nbsp;      temp.setInputParams(javaSorts);</b>
<b class="fc">&nbsp;      variables.put(variable, temp);</b>
<b class="fc">&nbsp;      key =</b>
<b class="fc">&nbsp;          umgr.callUF(</b>
<b class="fc">&nbsp;              (FunctionDeclaration&lt;? extends Formula&gt;) variables.get(variable).javaSmt,</b>
&nbsp;              inputParams);
<b class="fc">&nbsp;    } else {</b>
<b class="fc">&nbsp;      key = mapKey(returnTypes, variable);</b>
&nbsp;    }
&nbsp;
&nbsp;
<b class="fc">&nbsp;    Formula value = input;</b>
<b class="fc">&nbsp;    variables.put(variable, new ParserFormula(input));</b>
&nbsp;
<b class="fc">&nbsp;    String keyString = replaceReplacedChars(key.toString());</b>
<b class="fc">&nbsp;    String valueString = value.toString();</b>
<b class="fc">&nbsp;    if (isModel) {</b>
<b class="fc">&nbsp;      Model.ValueAssignment assignment =</b>
&nbsp;          new ValueAssignment(
<b class="fc">&nbsp;              key, value, mapEquivalence(key, value), keyString, valueString, new ArrayList&lt;&gt;());</b>
<b class="fc">&nbsp;      assignments.add(assignment);</b>
&nbsp;    }
<b class="fc">&nbsp;    return visitChildren(ctx);</b>
&nbsp;  }
&nbsp;
&nbsp;  @Override
&nbsp;  public Object visitCmd_assert(Cmd_assertContext ctx) {
<b class="fc">&nbsp;    Object result = visitChildren(ctx);</b>
&nbsp;    try {
<b class="fc">&nbsp;      constraints.add((BooleanFormula) result);</b>
<b class="fc">&nbsp;      return result;</b>
<b class="fc">&nbsp;    } catch (Exception pE) {</b>
<b class="fc">&nbsp;      throw new ParserException(&quot;constraints need to be of Boolean type&quot;);</b>
&nbsp;    }
&nbsp;  }
&nbsp;
&nbsp;  @Override
&nbsp;  public Object visitCmd_declareConst(Cmd_declareConstContext ctx) {
<b class="fc">&nbsp;    String variableSymbol = ctx.symbol().getText();</b>
<b class="fc">&nbsp;    FormulaType&lt;?&gt; sort = (FormulaType&lt;?&gt;) visit(ctx.sort());</b>
&nbsp;
<b class="fc">&nbsp;    if (sort.isBooleanType()) {</b>
<b class="fc">&nbsp;      variables.put(variableSymbol, new ParserFormula(bmgr.makeVariable(variableSymbol)));</b>
<b class="fc">&nbsp;    } else if (sort.isIntegerType()) {</b>
<b class="fc">&nbsp;      variables.put(</b>
&nbsp;          variableSymbol,
<b class="fc">&nbsp;          new ParserFormula(Objects.requireNonNull(imgr).makeVariable(variableSymbol)));</b>
<b class="fc">&nbsp;    } else if (sort.isRationalType()) {</b>
<b class="fc">&nbsp;      variables.put(</b>
&nbsp;          variableSymbol,
<b class="fc">&nbsp;          new ParserFormula(Objects.requireNonNull(rmgr).makeVariable(variableSymbol)));</b>
<b class="fc">&nbsp;    } else if (sort.isBitvectorType()) {</b>
<b class="fc">&nbsp;      variables.put(</b>
&nbsp;          variableSymbol,
&nbsp;          new ParserFormula(
<b class="fc">&nbsp;              Objects.requireNonNull(bimgr)</b>
<b class="fc">&nbsp;                  .makeVariable(((FormulaType.BitvectorType) sort).getSize(), variableSymbol)));</b>
<b class="pc">&nbsp;    } else if (sort.isArrayType()) {</b>
<b class="fc">&nbsp;      variables.put(</b>
&nbsp;          variableSymbol,
&nbsp;          new ParserFormula(
<b class="fc">&nbsp;              Objects.requireNonNull(amgr)</b>
<b class="fc">&nbsp;                  .makeArray(</b>
&nbsp;                      variableSymbol,
<b class="fc">&nbsp;                      ((FormulaType.ArrayFormulaType&lt;?, ?&gt;) sort).getIndexType(),</b>
<b class="fc">&nbsp;                      ((FormulaType.ArrayFormulaType&lt;?, ?&gt;) sort).getElementType())));</b>
&nbsp;    }
<b class="fc">&nbsp;    return visitChildren(ctx);</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * maps FormulaType to the corresponding SMT-LIB2 sort for the String representation of the model
&nbsp;   * @param type FormulaType that is needs to be translated to SMT-LIB2
&nbsp;   * @return String representation of FormulaType in SMT-LIB2
&nbsp;   */
&nbsp;  public static String getArrayStrings(FormulaType&lt;?&gt; type) {
&nbsp;
<b class="fc">&nbsp;    if (type.isBooleanType()) {</b>
<b class="fc">&nbsp;      return &quot;Bool&quot;;</b>
<b class="fc">&nbsp;    } else if (type.isIntegerType()) {</b>
<b class="fc">&nbsp;      return &quot;Int&quot;;</b>
<b class="pc">&nbsp;    } else if (type.isRationalType()) {</b>
<b class="nc">&nbsp;      return &quot;Real&quot;;</b>
<b class="fc">&nbsp;    } else if (type.isBitvectorType()) {</b>
<b class="fc">&nbsp;      return &quot;(_ BitVec &quot; + ((BitvectorType) type).getSize() + &quot;)&quot;;</b>
<b class="pc">&nbsp;    } else if (type.isArrayType()) {</b>
<b class="fc">&nbsp;      return &quot;(Array &quot;</b>
<b class="fc">&nbsp;          + getArrayStrings(((FormulaType.ArrayFormulaType&lt;?, ?&gt;) type).getIndexType())</b>
&nbsp;          + &quot; &quot;
<b class="fc">&nbsp;          + getArrayStrings(((FormulaType.ArrayFormulaType&lt;?, ?&gt;) type).getElementType());</b>
&nbsp;    } else {
<b class="nc">&nbsp;      throw new ParserException(type + &quot; is not a known Sort.&quot;);</b>
&nbsp;    }
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * creates a Formula object to use as the key in ValueAssignments for model from the given
&nbsp;   * FormulaType
&nbsp;   * @param sorts FormulaType of the value in ValueAssignments
&nbsp;   * @param variable String representation of the key in ValueAssignments
&nbsp;   * @return Formula matching the given FormulaType &#39;sorts&#39;
&nbsp;   */
&nbsp;  public Formula mapKey(FormulaType&lt;?&gt; sorts, String variable) {
&nbsp;
<b class="fc">&nbsp;    if (sorts.isBooleanType()) {</b>
<b class="fc">&nbsp;      return bmgr.makeVariable(variable);</b>
<b class="fc">&nbsp;    } else if (sorts.isIntegerType()) {</b>
<b class="fc">&nbsp;      return Objects.requireNonNull(imgr).makeVariable(variable);</b>
<b class="fc">&nbsp;    } else if (sorts.isRationalType()) {</b>
<b class="fc">&nbsp;      return Objects.requireNonNull(rmgr).makeVariable(variable);</b>
<b class="fc">&nbsp;    } else if (sorts.isBitvectorType()) {</b>
<b class="fc">&nbsp;      return Objects.requireNonNull(bimgr)</b>
<b class="fc">&nbsp;          .makeVariable(((FormulaType.BitvectorType) sorts).getSize(), variable);</b>
<b class="pc">&nbsp;    } else if (sorts.isArrayType()) {</b>
<b class="fc">&nbsp;      return Objects.requireNonNull(amgr)</b>
<b class="fc">&nbsp;          .makeArray(</b>
&nbsp;              variable,
<b class="fc">&nbsp;              ((FormulaType.ArrayFormulaType&lt;?, ?&gt;) sorts).getIndexType(),</b>
<b class="fc">&nbsp;              ((FormulaType.ArrayFormulaType&lt;?, ?&gt;) sorts).getElementType());</b>
&nbsp;    } else {
<b class="nc">&nbsp;      throw new ParserException(sorts + &quot; is not of a known Sort.&quot;);</b>
&nbsp;    }
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Assembles a BooleanFormula for the ValueAssignment field &#39;formula&#39; by applying
&nbsp;   * BooleanFormulaManager.equivalence() to key Formula and value Formula
&nbsp;   * @param key Variable name as Formula
&nbsp;   * @param value Variable value as Formula
&nbsp;   * @return Equivalence of key and value
&nbsp;   */
&nbsp;  public BooleanFormula mapEquivalence(Formula key, Formula value) {
<b class="fc">&nbsp;    if (key instanceof BooleanFormula) {</b>
<b class="fc">&nbsp;      return bmgr.equivalence((BooleanFormula) key, (BooleanFormula) value);</b>
<b class="pc">&nbsp;    } else if (key instanceof IntegerFormula) {</b>
<b class="nc">&nbsp;      return Objects.requireNonNull(imgr).equal((IntegerFormula) key, (IntegerFormula) value);</b>
<b class="pc">&nbsp;    } else if (key instanceof RationalFormula) {</b>
<b class="nc">&nbsp;      return Objects.requireNonNull(rmgr).equal((RationalFormula) key, (RationalFormula) value);</b>
<b class="fc">&nbsp;    } else if (key instanceof BitvectorFormula) {</b>
<b class="fc">&nbsp;      return Objects.requireNonNull(bimgr).equal((BitvectorFormula) key, (BitvectorFormula) value);</b>
<b class="pc">&nbsp;    } else if (key instanceof ArrayFormula) {</b>
<b class="fc">&nbsp;      return Objects.requireNonNull(amgr)</b>
<b class="fc">&nbsp;          .equivalence(</b>
&nbsp;              (ArrayFormula&lt;Formula, Formula&gt;) key, (ArrayFormula&lt;Formula, Formula&gt;) value);
&nbsp;    } else {
<b class="nc">&nbsp;      throw new ParserException(key + &quot; is not a valid Sort&quot;);</b>
&nbsp;    }
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Checks if String contains forbidden characters and temporarily replaces them, can be undone with
&nbsp;   * &#39;replaceReplacedChars()&#39;.
&nbsp;   * @param variable String that is checked and modified if necessary
&nbsp;   * @return String with no forbidden characters
&nbsp;   */
&nbsp;  public String replaceReservedChars(String variable) {
<b class="pc">&nbsp;    if (variable.startsWith(&quot;|&quot;)) {</b>
<b class="nc">&nbsp;      return variable.replaceAll(&quot;\\|&quot;, &quot;PIPE&quot;);</b>
<b class="pc">&nbsp;    } else if (variable.contains(&quot;\\&quot;)) {</b>
<b class="nc">&nbsp;      return variable.replaceAll(&quot;\\\\&quot;, &quot;BACKSLASH&quot;);</b>
&nbsp;    } else {
<b class="fc">&nbsp;      return variable;</b>
&nbsp;    }
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Reverses &#39;replaceReservedChars&#39;
&nbsp;   * @param variable String that is checked for necessary char replacements
&nbsp;   * @return modified String
&nbsp;   */
&nbsp;  public String replaceReplacedChars(String variable) {
<b class="pc">&nbsp;    if (variable.contains(&quot;PIPE&quot;)) {</b>
<b class="nc">&nbsp;      return variable.replaceAll(&quot;PIPE&quot;, &quot;|&quot;);</b>
<b class="pc">&nbsp;    } else if (variable.contains(&quot;BACKSLASH&quot;)) {</b>
<b class="nc">&nbsp;      return variable.replaceAll(&quot;BACKSLASH&quot;, &quot;\\&quot;);</b>
&nbsp;    } else {
<b class="fc">&nbsp;      return variable;</b>
&nbsp;    }
&nbsp;  }
&nbsp;
&nbsp;  @Override
&nbsp;  public Object visitCmd_declareFun(Cmd_declareFunContext ctx) {
<b class="fc">&nbsp;    String variable = replaceReservedChars(ctx.symbol().getText());</b>
&nbsp;
<b class="fc">&nbsp;    FormulaType&lt;?&gt; returnType = (FormulaType&lt;?&gt;) visit(ctx.sort(ctx.sort().size()-1));</b>
&nbsp;
<b class="fc">&nbsp;    List&lt;FormulaType&lt;?&gt;&gt; inputParams = new ArrayList&lt;&gt;();</b>
<b class="fc">&nbsp;    if (ctx.sort().size() &gt; 1) {</b>
<b class="fc">&nbsp;      for (int i = 0; i &lt; ctx.sort().size() - 1; i++) {</b>
<b class="fc">&nbsp;        inputParams.add((FormulaType&lt;?&gt;) visit(ctx.sort(i)));</b>
&nbsp;      }
&nbsp;    }
&nbsp;
<b class="fc">&nbsp;    ParserFormula temp =</b>
&nbsp;        new ParserFormula(
<b class="fc">&nbsp;            umgr.declareUF(variable, returnType, inputParams));</b>
<b class="fc">&nbsp;    temp.setType(&quot;UF&quot;);</b>
<b class="fc">&nbsp;    temp.setReturnType(returnType);</b>
<b class="fc">&nbsp;    temp.setInputParams(inputParams);</b>
<b class="fc">&nbsp;    variables.put(variable, temp);</b>
&nbsp;
<b class="fc">&nbsp;    return visitChildren(ctx);</b>
&nbsp;  }
&nbsp;
&nbsp;  @Override
&nbsp;  public Object visitCmd_pop(Cmd_popContext ctx) {
<b class="fc">&nbsp;    throw new ParserException(&quot;Parser does not support \&quot;pop\&quot;&quot;);</b>
&nbsp;  }
&nbsp;
&nbsp;  @Override
&nbsp;  public Object visitCmd_push(Cmd_pushContext ctx) {
<b class="fc">&nbsp;    throw new ParserException(&quot;Parser does not support \&quot;push\&quot;&quot;);</b>
&nbsp;  }
&nbsp;
&nbsp;  @Override
&nbsp;  public Object visitDecl_sort(Decl_sortContext ctx) {
<b class="fc">&nbsp;    throw new ParserException(&quot;JavaSMT does not support \&quot;declare-sort\&quot;&quot;);</b>
&nbsp;  }
&nbsp;
&nbsp;  @Override
&nbsp;  public Object visitResp_get_model(Resp_get_modelContext ctx) {
<b class="fc">&nbsp;    isModel = true;</b>
<b class="fc">&nbsp;    return visitChildren(ctx);</b>
&nbsp;  }
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2023-12-17 16:11</div>
</div>
</body>
</html>
